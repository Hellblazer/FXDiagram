package de.fxdiagram.annotations.properties

import java.lang.annotation.ElementType
import java.lang.annotation.Target
import javafx.beans.property.BooleanProperty
import javafx.beans.property.DoubleProperty
import javafx.beans.property.FloatProperty
import javafx.beans.property.IntegerProperty
import javafx.beans.property.ListProperty
import javafx.beans.property.LongProperty
import javafx.beans.property.Property
import javafx.beans.property.StringProperty
import org.eclipse.xtend.lib.macro.AbstractClassProcessor
import org.eclipse.xtend.lib.macro.Active
import org.eclipse.xtend.lib.macro.TransformationContext
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.MemberDeclaration
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.TypeReference
import org.eclipse.xtend.lib.macro.declaration.Visibility

@Active(ModelNodeProcessor)
@Target(ElementType.TYPE)
annotation ModelNode {
	String[] value = #[]
}

class ModelNodeProcessor extends AbstractClassProcessor {
	
	extension TransformationContext context 
	
	override doTransform(MutableClassDeclaration annotatedClass, TransformationContext context) {
		this.context = context
		val modelAnnotation = annotatedClass.findAnnotation(findTypeGlobally(ModelNode))
		val properties = modelAnnotation
			.getStringArrayValue('value')
			.map[
				val accessor = getPropertyAccessor(annotatedClass, it, true)
				if(accessor == null) {
					annotatedClass.addError("Cannot find JavaFX property '" + it + "'")
					return null					
				} else if(accessor.componentType == null) {
					annotatedClass.addError("Could not resolve component type from  '" + accessor.asCall + "'")
					return null					
				}  
				accessor
			]
			.filterNull
		val modelProviderType = newTypeReference('de.fxdiagram.core.model.XModelProvider')
		val superImplementsXModelProvider = modelProviderType.isAssignableFrom(annotatedClass.extendedClass)
		val existingNoArgConstructor = annotatedClass.findDeclaredConstructor()
		// this will remove implicit no-arg constructors
		annotatedClass.addConstructor[
			addParameter('modelLoad', newTypeReference('de.fxdiagram.core.model.ModelLoad'))
			docComment = 'Automatically generated by @ModelNode. Used in model deserialization.'
			if(superImplementsXModelProvider) {
				body = '''
					super(modelLoad);
				'''
			}
		]
		// re-add removed default constructors 
		val survivingNoArgConstructor = annotatedClass.findDeclaredConstructor()
		if(existingNoArgConstructor != null && survivingNoArgConstructor == null) {
			annotatedClass.addConstructor[
				docComment = 'Automatically generated by @ModelNode'
			]
		}
		if(!modelProviderType.type.isAssignableFrom(annotatedClass))
			annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces + #[modelProviderType]
		annotatedClass.addMethod('populate', [
			addParameter('modelElement', newTypeReference('de.fxdiagram.core.model.ModelElement'))
			body = '''
				«FOR property: properties»
					modelElement.addProperty(«property.asCall», «property.componentType».class);
				«ENDFOR»
			'''
		])
	}
	
	protected def PropertyAccessor getPropertyAccessor(ClassDeclaration clazz, String propertyName, boolean allowPrivate) {
		val field = clazz.findDeclaredField(propertyName) 
			?: clazz.findDeclaredField((propertyName + 'Property'))
		if(field != null && (allowPrivate || field.visibility != Visibility.PRIVATE)) 
			return new PropertyAccessor(field, componentType(field.type))
		val method = clazz.findDeclaredMethod(propertyName)
			?: clazz.findDeclaredMethod((propertyName + 'Property'))
			?: clazz.findDeclaredMethod(('get' + propertyName.toFirstUpper)) 
		if(method != null && (allowPrivate || method.visibility != Visibility.PRIVATE)) 
			return new PropertyAccessor(method, componentType(method.returnType))
		if(clazz.extendedClass != null) 
			return getPropertyAccessor(clazz.extendedClass.type as ClassDeclaration, propertyName, false)
		return null
	}
	
	protected def TypeReference componentType(TypeReference it) {
		if(newTypeReference(Property, newWildcardTypeReference).isAssignableFrom(it))
			return isListType(Double)
				?: isListType(String)
				?: isListType(Integer)
				?: isListType(Boolean)
				?: isListType(Long)
				?: isListType(Float)
				?: isListType(Enum)
				?: isListType(Object)
			    ?: isType(DoubleProperty, Double) 
				?: isType(StringProperty, String)
				?: isType(IntegerProperty, Integer)
				?: isType(BooleanProperty, Boolean)
				?: isType(LongProperty, Long)
				?: isType(FloatProperty, Float)
				?: actualTypeArguments.head
		else 
			return null
	}
	
	protected def TypeReference isType(TypeReference typeRef, Class<? extends Property<?>> propertyType, Class<?> clazz) {
		if(newTypeReference(propertyType).isAssignableFrom(typeRef)) 
			return newTypeReference(clazz)
		else
			return null
	}

	protected def TypeReference isListType(TypeReference typeRef, Class<?> clazz) {
		val componentType = newTypeReference(clazz)
		if(newTypeReference(ListProperty, componentType).isAssignableFrom(typeRef)) 
			return componentType
		else
			return null
	}
}

@Data
class PropertyAccessor {
	MemberDeclaration member
	TypeReference componentType
	
	def asCall() {
		member.simpleName + (if (member instanceof MethodDeclaration) '()' else '')
	}
}