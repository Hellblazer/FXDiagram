package de.fxdiagram.annotations.properties;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import de.fxdiagram.annotations.properties.ModelNode;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.FloatProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ListProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.Property;
import javafx.beans.property.StringProperty;
import org.eclipse.xtend.lib.macro.AbstractClassProcessor;
import org.eclipse.xtend.lib.macro.TransformationContext;
import org.eclipse.xtend.lib.macro.declaration.AnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.FieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MemberDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.declaration.Visibility;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class ModelNodeProcessor extends AbstractClassProcessor {
  @Extension
  private TransformationContext context;
  
  public void doTransform(final MutableClassDeclaration annotatedClass, final TransformationContext context) {
    this.context = context;
    Type _findTypeGlobally = this.context.findTypeGlobally(ModelNode.class);
    final AnnotationReference modelAnnotation = annotatedClass.findAnnotation(_findTypeGlobally);
    final ArrayList<String> validPropertyNames = CollectionLiterals.<String>newArrayList();
    String[] _stringArrayValue = modelAnnotation.getStringArrayValue("value");
    final Procedure1<String> _function = new Procedure1<String>() {
      public void apply(final String it) {
        final MemberDeclaration accessor = ModelNodeProcessor.this.getPropertyAccessor(annotatedClass, it, true);
        boolean _equals = Objects.equal(accessor, null);
        if (_equals) {
          ModelNodeProcessor.this.context.addError(modelAnnotation, (("Cannot find JavaFX property \'" + it) + "\'"));
        } else {
          validPropertyNames.add(it);
        }
      }
    };
    IterableExtensions.<String>forEach(((Iterable<String>)Conversions.doWrapArray(_stringArrayValue)), _function);
    final MutableConstructorDeclaration existingNoArgConstructor = annotatedClass.findDeclaredConstructor();
    boolean _equals = Objects.equal(existingNoArgConstructor, null);
    if (_equals) {
      final Procedure1<MutableConstructorDeclaration> _function_1 = new Procedure1<MutableConstructorDeclaration>() {
        public void apply(final MutableConstructorDeclaration it) {
          it.setDocComment("Automatically generated by @ModelNode. Needed for deserialization.");
        }
      };
      annotatedClass.addConstructor(_function_1);
    }
    final TypeReference modelProviderType = this.context.newTypeReference("de.fxdiagram.core.model.XModelProvider");
    boolean _and = false;
    boolean _and_1 = false;
    Object _value = modelAnnotation.getValue("inherit");
    boolean _notEquals = (!Objects.equal(_value, Boolean.FALSE));
    if (!_notEquals) {
      _and_1 = false;
    } else {
      TypeReference _extendedClass = annotatedClass.getExtendedClass();
      boolean _notEquals_1 = (!Objects.equal(_extendedClass, null));
      _and_1 = _notEquals_1;
    }
    if (!_and_1) {
      _and = false;
    } else {
      TypeReference _extendedClass_1 = annotatedClass.getExtendedClass();
      boolean _isAssignableFrom = modelProviderType.isAssignableFrom(_extendedClass_1);
      _and = _isAssignableFrom;
    }
    final boolean isInherit = _and;
    Type _type = modelProviderType.getType();
    boolean _isAssignableFrom_1 = _type.isAssignableFrom(annotatedClass);
    boolean _not = (!_isAssignableFrom_1);
    if (_not) {
      Iterable<? extends TypeReference> _implementedInterfaces = annotatedClass.getImplementedInterfaces();
      Iterable<TypeReference> _plus = Iterables.<TypeReference>concat(_implementedInterfaces, Collections.<TypeReference>unmodifiableList(Lists.<TypeReference>newArrayList(modelProviderType)));
      annotatedClass.setImplementedInterfaces(_plus);
    }
    final Procedure1<MutableMethodDeclaration> _function_2 = new Procedure1<MutableMethodDeclaration>() {
      public void apply(final MutableMethodDeclaration it) {
        TypeReference _newTypeReference = ModelNodeProcessor.this.context.newTypeReference("de.fxdiagram.core.model.ModelElementImpl");
        it.addParameter("modelElement", _newTypeReference);
        StringConcatenationClient _client = new StringConcatenationClient() {
          @Override
          protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
            {
              if (isInherit) {
                _builder.append("super.populate(modelElement);");
              }
            }
            _builder.newLineIfNotEmpty();
            {
              final Function1<String, MemberDeclaration> _function = new Function1<String, MemberDeclaration>() {
                public MemberDeclaration apply(final String it) {
                  return ModelNodeProcessor.this.getPropertyAccessor(annotatedClass, it, true);
                }
              };
              List<MemberDeclaration> _map = ListExtensions.<String, MemberDeclaration>map(validPropertyNames, _function);
              for(final MemberDeclaration accessor : _map) {
                _builder.append("modelElement.addProperty(");
                String _call = ModelNodeProcessor.this.getCall(accessor);
                _builder.append(_call, "");
                _builder.append(", ");
                TypeReference _componentType = ModelNodeProcessor.this.getComponentType(accessor);
                Type _type = _componentType.getType();
                TypeReference _newTypeReference = ModelNodeProcessor.this.context.newTypeReference(_type);
                _builder.append(_newTypeReference, "");
                _builder.append(".class);");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        };
        it.setBody(_client);
      }
    };
    annotatedClass.addMethod("populate", _function_2);
  }
  
  protected CharSequence getHierarchy(final ClassDeclaration clazz) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Class: ");
    String _simpleName = clazz.getSimpleName();
    _builder.append(_simpleName, "");
    _builder.newLineIfNotEmpty();
    {
      Iterable<? extends MethodDeclaration> _declaredMethods = clazz.getDeclaredMethods();
      for(final MethodDeclaration m : _declaredMethods) {
        _builder.append("\t");
        String _simpleName_1 = m.getSimpleName();
        _builder.append(_simpleName_1, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    CharSequence _elvis = null;
    TypeReference _extendedClass = clazz.getExtendedClass();
    Type _type = null;
    if (_extendedClass!=null) {
      _type=_extendedClass.getType();
    }
    CharSequence _hierarchy = null;
    if (((ClassDeclaration) _type)!=null) {
      Type _type_1 = null;
      if (_extendedClass!=null) {
        _type=_extendedClass.getType();
      }
      _hierarchy=this.getHierarchy(((ClassDeclaration) _type));
    }
    if (_hierarchy != null) {
      _elvis = _hierarchy;
    } else {
      _elvis = "";
    }
    _builder.append(_elvis, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected MemberDeclaration getPropertyAccessor(final ClassDeclaration clazz, final String propertyName, final boolean allowPrivate) {
    FieldDeclaration _elvis = null;
    FieldDeclaration _findDeclaredField = clazz.findDeclaredField(propertyName);
    if (_findDeclaredField != null) {
      _elvis = _findDeclaredField;
    } else {
      FieldDeclaration _findDeclaredField_1 = clazz.findDeclaredField((propertyName + "Property"));
      _elvis = _findDeclaredField_1;
    }
    final FieldDeclaration field = _elvis;
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(field, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _or = false;
      if (allowPrivate) {
        _or = true;
      } else {
        Visibility _visibility = field.getVisibility();
        boolean _notEquals_1 = (!Objects.equal(_visibility, Visibility.PRIVATE));
        _or = _notEquals_1;
      }
      _and = _or;
    }
    if (_and) {
      return field;
    }
    MethodDeclaration _elvis_1 = null;
    MethodDeclaration _elvis_2 = null;
    MethodDeclaration _findDeclaredMethod = clazz.findDeclaredMethod(propertyName);
    if (_findDeclaredMethod != null) {
      _elvis_2 = _findDeclaredMethod;
    } else {
      MethodDeclaration _findDeclaredMethod_1 = clazz.findDeclaredMethod((propertyName + "Property"));
      _elvis_2 = _findDeclaredMethod_1;
    }
    if (_elvis_2 != null) {
      _elvis_1 = _elvis_2;
    } else {
      String _firstUpper = StringExtensions.toFirstUpper(propertyName);
      String _plus = ("get" + _firstUpper);
      MethodDeclaration _findDeclaredMethod_2 = clazz.findDeclaredMethod(_plus);
      _elvis_1 = _findDeclaredMethod_2;
    }
    final MethodDeclaration method = _elvis_1;
    boolean _and_1 = false;
    boolean _notEquals_2 = (!Objects.equal(method, null));
    if (!_notEquals_2) {
      _and_1 = false;
    } else {
      boolean _or_1 = false;
      if (allowPrivate) {
        _or_1 = true;
      } else {
        Visibility _visibility_1 = method.getVisibility();
        boolean _notEquals_3 = (!Objects.equal(_visibility_1, Visibility.PRIVATE));
        _or_1 = _notEquals_3;
      }
      _and_1 = _or_1;
    }
    if (_and_1) {
      return method;
    }
    TypeReference _extendedClass = clazz.getExtendedClass();
    boolean _notEquals_4 = (!Objects.equal(_extendedClass, null));
    if (_notEquals_4) {
      TypeReference _extendedClass_1 = clazz.getExtendedClass();
      Type _type = _extendedClass_1.getType();
      return this.getPropertyAccessor(((ClassDeclaration) _type), propertyName, false);
    }
    return null;
  }
  
  protected TypeReference getComponentType(final MemberDeclaration member) {
    TypeReference _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (member instanceof MethodDeclaration) {
        _matched=true;
        _switchResult = ((MethodDeclaration)member).getReturnType();
      }
    }
    if (!_matched) {
      if (member instanceof FieldDeclaration) {
        _matched=true;
        _switchResult = ((FieldDeclaration)member).getType();
      }
    }
    if (!_matched) {
      _switchResult = this.context.getObject();
    }
    return this.getComponentType(_switchResult);
  }
  
  protected String getCall(final MemberDeclaration member) {
    String _simpleName = member.getSimpleName();
    String _xifexpression = null;
    if ((member instanceof MethodDeclaration)) {
      _xifexpression = "()";
    } else {
      _xifexpression = "";
    }
    return (_simpleName + _xifexpression);
  }
  
  protected TypeReference getComponentType(final TypeReference it) {
    TypeReference _newWildcardTypeReference = this.context.newWildcardTypeReference();
    TypeReference _newTypeReference = this.context.newTypeReference(Property.class, _newWildcardTypeReference);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(it);
    if (_isAssignableFrom) {
      TypeReference _elvis = null;
      TypeReference _elvis_1 = null;
      TypeReference _elvis_2 = null;
      TypeReference _elvis_3 = null;
      TypeReference _elvis_4 = null;
      TypeReference _elvis_5 = null;
      TypeReference _elvis_6 = null;
      TypeReference _elvis_7 = null;
      TypeReference _elvis_8 = null;
      TypeReference _elvis_9 = null;
      TypeReference _elvis_10 = null;
      TypeReference _elvis_11 = null;
      TypeReference _elvis_12 = null;
      TypeReference _elvis_13 = null;
      TypeReference _isListType = this.isListType(it, Double.class);
      if (_isListType != null) {
        _elvis_13 = _isListType;
      } else {
        TypeReference _isListType_1 = this.isListType(it, String.class);
        _elvis_13 = _isListType_1;
      }
      if (_elvis_13 != null) {
        _elvis_12 = _elvis_13;
      } else {
        TypeReference _isListType_2 = this.isListType(it, Integer.class);
        _elvis_12 = _isListType_2;
      }
      if (_elvis_12 != null) {
        _elvis_11 = _elvis_12;
      } else {
        TypeReference _isListType_3 = this.isListType(it, Boolean.class);
        _elvis_11 = _isListType_3;
      }
      if (_elvis_11 != null) {
        _elvis_10 = _elvis_11;
      } else {
        TypeReference _isListType_4 = this.isListType(it, Long.class);
        _elvis_10 = _isListType_4;
      }
      if (_elvis_10 != null) {
        _elvis_9 = _elvis_10;
      } else {
        TypeReference _isListType_5 = this.isListType(it, Float.class);
        _elvis_9 = _isListType_5;
      }
      if (_elvis_9 != null) {
        _elvis_8 = _elvis_9;
      } else {
        TypeReference _isListType_6 = this.isListType(it, Enum.class);
        _elvis_8 = _isListType_6;
      }
      if (_elvis_8 != null) {
        _elvis_7 = _elvis_8;
      } else {
        TypeReference _isListType_7 = this.isListType(it, Object.class);
        _elvis_7 = _isListType_7;
      }
      if (_elvis_7 != null) {
        _elvis_6 = _elvis_7;
      } else {
        TypeReference _isType = this.isType(it, DoubleProperty.class, Double.class);
        _elvis_6 = _isType;
      }
      if (_elvis_6 != null) {
        _elvis_5 = _elvis_6;
      } else {
        TypeReference _isType_1 = this.isType(it, StringProperty.class, String.class);
        _elvis_5 = _isType_1;
      }
      if (_elvis_5 != null) {
        _elvis_4 = _elvis_5;
      } else {
        TypeReference _isType_2 = this.isType(it, IntegerProperty.class, Integer.class);
        _elvis_4 = _isType_2;
      }
      if (_elvis_4 != null) {
        _elvis_3 = _elvis_4;
      } else {
        TypeReference _isType_3 = this.isType(it, BooleanProperty.class, Boolean.class);
        _elvis_3 = _isType_3;
      }
      if (_elvis_3 != null) {
        _elvis_2 = _elvis_3;
      } else {
        TypeReference _isType_4 = this.isType(it, LongProperty.class, Long.class);
        _elvis_2 = _isType_4;
      }
      if (_elvis_2 != null) {
        _elvis_1 = _elvis_2;
      } else {
        TypeReference _isType_5 = this.isType(it, FloatProperty.class, Float.class);
        _elvis_1 = _isType_5;
      }
      if (_elvis_1 != null) {
        _elvis = _elvis_1;
      } else {
        List<TypeReference> _actualTypeArguments = it.getActualTypeArguments();
        TypeReference _head = IterableExtensions.<TypeReference>head(_actualTypeArguments);
        _elvis = _head;
      }
      return _elvis;
    } else {
      return null;
    }
  }
  
  protected TypeReference isType(final TypeReference typeRef, final Class<? extends Property<?>> propertyType, final Class<?> clazz) {
    TypeReference _newTypeReference = this.context.newTypeReference(propertyType);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(typeRef);
    if (_isAssignableFrom) {
      return this.context.newTypeReference(clazz);
    } else {
      return null;
    }
  }
  
  protected TypeReference isListType(final TypeReference typeRef, final Class<?> clazz) {
    final TypeReference componentType = this.context.newTypeReference(clazz);
    TypeReference _newTypeReference = this.context.newTypeReference(ListProperty.class, componentType);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(typeRef);
    if (_isAssignableFrom) {
      return componentType;
    } else {
      return null;
    }
  }
}
