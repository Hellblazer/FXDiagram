package de.fxdiagram.annotations.properties;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import de.fxdiagram.annotations.properties.ModelNode;
import de.fxdiagram.annotations.properties.PropertyAccessor;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.FloatProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ListProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.Property;
import javafx.beans.property.StringProperty;
import org.eclipse.xtend.lib.macro.AbstractClassProcessor;
import org.eclipse.xtend.lib.macro.TransformationContext;
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.FieldDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableAnnotationReference;
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableConstructorDeclaration;
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration;
import org.eclipse.xtend.lib.macro.declaration.Type;
import org.eclipse.xtend.lib.macro.declaration.TypeReference;
import org.eclipse.xtend.lib.macro.declaration.Visibility;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class ModelNodeProcessor extends AbstractClassProcessor {
  @Extension
  private TransformationContext context;
  
  public void doTransform(final MutableClassDeclaration annotatedClass, final TransformationContext context) {
    this.context = context;
    Type _findTypeGlobally = this.context.findTypeGlobally(ModelNode.class);
    final MutableAnnotationReference modelAnnotation = annotatedClass.findAnnotation(_findTypeGlobally);
    String[] _stringArrayValue = modelAnnotation.getStringArrayValue("value");
    final Function1<String,PropertyAccessor> _function = new Function1<String,PropertyAccessor>() {
      public PropertyAccessor apply(final String it) {
        PropertyAccessor _xblockexpression = null;
        {
          final PropertyAccessor accessor = ModelNodeProcessor.this.getPropertyAccessor(annotatedClass, it, true);
          boolean _equals = Objects.equal(accessor, null);
          if (_equals) {
            ModelNodeProcessor.this.context.addError(annotatedClass, (("Cannot find JavaFX property \'" + it) + "\'"));
            return null;
          } else {
            TypeReference _componentType = accessor.getComponentType();
            boolean _equals_1 = Objects.equal(_componentType, null);
            if (_equals_1) {
              String _asCall = accessor.asCall();
              String _plus = ("Could not resolve component type from  \'" + _asCall);
              String _plus_1 = (_plus + "\'");
              ModelNodeProcessor.this.context.addError(annotatedClass, _plus_1);
              return null;
            }
          }
          _xblockexpression = accessor;
        }
        return _xblockexpression;
      }
    };
    List<PropertyAccessor> _map = ListExtensions.<String, PropertyAccessor>map(((List<String>)Conversions.doWrapArray(_stringArrayValue)), _function);
    final Iterable<PropertyAccessor> properties = IterableExtensions.<PropertyAccessor>filterNull(_map);
    final TypeReference modelProviderType = this.context.newTypeReference("de.fxdiagram.core.model.XModelProvider");
    TypeReference _extendedClass = annotatedClass.getExtendedClass();
    final boolean superImplementsXModelProvider = modelProviderType.isAssignableFrom(_extendedClass);
    final MutableConstructorDeclaration existingNoArgConstructor = annotatedClass.findDeclaredConstructor();
    final Procedure1<MutableConstructorDeclaration> _function_1 = new Procedure1<MutableConstructorDeclaration>() {
      public void apply(final MutableConstructorDeclaration it) {
        TypeReference _newTypeReference = ModelNodeProcessor.this.context.newTypeReference("de.fxdiagram.core.model.ModelLoad");
        it.addParameter("modelLoad", _newTypeReference);
        it.setDocComment("Automatically generated by @ModelNode. Used in model deserialization.");
        if (superImplementsXModelProvider) {
          StringConcatenationClient _client = new StringConcatenationClient() {
            @Override
            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
              _builder.append("super(modelLoad);");
              _builder.newLine();
            }
          };
          it.setBody(_client);
        }
      }
    };
    annotatedClass.addConstructor(_function_1);
    final MutableConstructorDeclaration survivingNoArgConstructor = annotatedClass.findDeclaredConstructor();
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(existingNoArgConstructor, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _equals = Objects.equal(survivingNoArgConstructor, null);
      _and = _equals;
    }
    if (_and) {
      final Procedure1<MutableConstructorDeclaration> _function_2 = new Procedure1<MutableConstructorDeclaration>() {
        public void apply(final MutableConstructorDeclaration it) {
          it.setDocComment("Automatically generated by @ModelNode");
        }
      };
      annotatedClass.addConstructor(_function_2);
    }
    Type _type = modelProviderType.getType();
    boolean _isAssignableFrom = _type.isAssignableFrom(annotatedClass);
    boolean _not = (!_isAssignableFrom);
    if (_not) {
      Iterable<? extends TypeReference> _implementedInterfaces = annotatedClass.getImplementedInterfaces();
      Iterable<TypeReference> _plus = Iterables.<TypeReference>concat(_implementedInterfaces, Collections.<TypeReference>unmodifiableList(Lists.<TypeReference>newArrayList(modelProviderType)));
      annotatedClass.setImplementedInterfaces(_plus);
    }
    final Procedure1<MutableMethodDeclaration> _function_3 = new Procedure1<MutableMethodDeclaration>() {
      public void apply(final MutableMethodDeclaration it) {
        TypeReference _newTypeReference = ModelNodeProcessor.this.context.newTypeReference("de.fxdiagram.core.model.ModelElement");
        it.addParameter("modelElement", _newTypeReference);
        StringConcatenationClient _client = new StringConcatenationClient() {
          @Override
          protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
            {
              for(final PropertyAccessor property : properties) {
                _builder.append("modelElement.addProperty(");
                String _asCall = property.asCall();
                _builder.append(_asCall, "");
                _builder.append(", ");
                TypeReference _componentType = property.getComponentType();
                _builder.append(_componentType, "");
                _builder.append(".class);");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        };
        it.setBody(_client);
      }
    };
    annotatedClass.addMethod("populate", _function_3);
  }
  
  protected PropertyAccessor getPropertyAccessor(final ClassDeclaration clazz, final String propertyName, final boolean allowPrivate) {
    FieldDeclaration _elvis = null;
    FieldDeclaration _findDeclaredField = clazz.findDeclaredField(propertyName);
    if (_findDeclaredField != null) {
      _elvis = _findDeclaredField;
    } else {
      FieldDeclaration _findDeclaredField_1 = clazz.findDeclaredField((propertyName + "Property"));
      _elvis = _findDeclaredField_1;
    }
    final FieldDeclaration field = _elvis;
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(field, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _or = false;
      if (allowPrivate) {
        _or = true;
      } else {
        Visibility _visibility = field.getVisibility();
        boolean _notEquals_1 = (!Objects.equal(_visibility, Visibility.PRIVATE));
        _or = _notEquals_1;
      }
      _and = _or;
    }
    if (_and) {
      TypeReference _type = field.getType();
      TypeReference _componentType = this.componentType(_type);
      return new PropertyAccessor(field, _componentType);
    }
    MethodDeclaration _elvis_1 = null;
    MethodDeclaration _elvis_2 = null;
    MethodDeclaration _findDeclaredMethod = clazz.findDeclaredMethod(propertyName);
    if (_findDeclaredMethod != null) {
      _elvis_2 = _findDeclaredMethod;
    } else {
      MethodDeclaration _findDeclaredMethod_1 = clazz.findDeclaredMethod((propertyName + "Property"));
      _elvis_2 = _findDeclaredMethod_1;
    }
    if (_elvis_2 != null) {
      _elvis_1 = _elvis_2;
    } else {
      String _firstUpper = StringExtensions.toFirstUpper(propertyName);
      String _plus = ("get" + _firstUpper);
      MethodDeclaration _findDeclaredMethod_2 = clazz.findDeclaredMethod(_plus);
      _elvis_1 = _findDeclaredMethod_2;
    }
    final MethodDeclaration method = _elvis_1;
    boolean _and_1 = false;
    boolean _notEquals_2 = (!Objects.equal(method, null));
    if (!_notEquals_2) {
      _and_1 = false;
    } else {
      boolean _or_1 = false;
      if (allowPrivate) {
        _or_1 = true;
      } else {
        Visibility _visibility_1 = method.getVisibility();
        boolean _notEquals_3 = (!Objects.equal(_visibility_1, Visibility.PRIVATE));
        _or_1 = _notEquals_3;
      }
      _and_1 = _or_1;
    }
    if (_and_1) {
      TypeReference _returnType = method.getReturnType();
      TypeReference _componentType_1 = this.componentType(_returnType);
      return new PropertyAccessor(method, _componentType_1);
    }
    TypeReference _extendedClass = clazz.getExtendedClass();
    boolean _notEquals_4 = (!Objects.equal(_extendedClass, null));
    if (_notEquals_4) {
      TypeReference _extendedClass_1 = clazz.getExtendedClass();
      Type _type_1 = _extendedClass_1.getType();
      return this.getPropertyAccessor(((ClassDeclaration) _type_1), propertyName, false);
    }
    return null;
  }
  
  protected TypeReference componentType(final TypeReference it) {
    TypeReference _newWildcardTypeReference = this.context.newWildcardTypeReference();
    TypeReference _newTypeReference = this.context.newTypeReference(Property.class, _newWildcardTypeReference);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(it);
    if (_isAssignableFrom) {
      TypeReference _elvis = null;
      TypeReference _elvis_1 = null;
      TypeReference _elvis_2 = null;
      TypeReference _elvis_3 = null;
      TypeReference _elvis_4 = null;
      TypeReference _elvis_5 = null;
      TypeReference _elvis_6 = null;
      TypeReference _elvis_7 = null;
      TypeReference _elvis_8 = null;
      TypeReference _elvis_9 = null;
      TypeReference _elvis_10 = null;
      TypeReference _elvis_11 = null;
      TypeReference _elvis_12 = null;
      TypeReference _elvis_13 = null;
      TypeReference _isListType = this.isListType(it, Double.class);
      if (_isListType != null) {
        _elvis_13 = _isListType;
      } else {
        TypeReference _isListType_1 = this.isListType(it, String.class);
        _elvis_13 = _isListType_1;
      }
      if (_elvis_13 != null) {
        _elvis_12 = _elvis_13;
      } else {
        TypeReference _isListType_2 = this.isListType(it, Integer.class);
        _elvis_12 = _isListType_2;
      }
      if (_elvis_12 != null) {
        _elvis_11 = _elvis_12;
      } else {
        TypeReference _isListType_3 = this.isListType(it, Boolean.class);
        _elvis_11 = _isListType_3;
      }
      if (_elvis_11 != null) {
        _elvis_10 = _elvis_11;
      } else {
        TypeReference _isListType_4 = this.isListType(it, Long.class);
        _elvis_10 = _isListType_4;
      }
      if (_elvis_10 != null) {
        _elvis_9 = _elvis_10;
      } else {
        TypeReference _isListType_5 = this.isListType(it, Float.class);
        _elvis_9 = _isListType_5;
      }
      if (_elvis_9 != null) {
        _elvis_8 = _elvis_9;
      } else {
        TypeReference _isListType_6 = this.isListType(it, Enum.class);
        _elvis_8 = _isListType_6;
      }
      if (_elvis_8 != null) {
        _elvis_7 = _elvis_8;
      } else {
        TypeReference _isListType_7 = this.isListType(it, Object.class);
        _elvis_7 = _isListType_7;
      }
      if (_elvis_7 != null) {
        _elvis_6 = _elvis_7;
      } else {
        TypeReference _isType = this.isType(it, DoubleProperty.class, Double.class);
        _elvis_6 = _isType;
      }
      if (_elvis_6 != null) {
        _elvis_5 = _elvis_6;
      } else {
        TypeReference _isType_1 = this.isType(it, StringProperty.class, String.class);
        _elvis_5 = _isType_1;
      }
      if (_elvis_5 != null) {
        _elvis_4 = _elvis_5;
      } else {
        TypeReference _isType_2 = this.isType(it, IntegerProperty.class, Integer.class);
        _elvis_4 = _isType_2;
      }
      if (_elvis_4 != null) {
        _elvis_3 = _elvis_4;
      } else {
        TypeReference _isType_3 = this.isType(it, BooleanProperty.class, Boolean.class);
        _elvis_3 = _isType_3;
      }
      if (_elvis_3 != null) {
        _elvis_2 = _elvis_3;
      } else {
        TypeReference _isType_4 = this.isType(it, LongProperty.class, Long.class);
        _elvis_2 = _isType_4;
      }
      if (_elvis_2 != null) {
        _elvis_1 = _elvis_2;
      } else {
        TypeReference _isType_5 = this.isType(it, FloatProperty.class, Float.class);
        _elvis_1 = _isType_5;
      }
      if (_elvis_1 != null) {
        _elvis = _elvis_1;
      } else {
        List<TypeReference> _actualTypeArguments = it.getActualTypeArguments();
        TypeReference _head = IterableExtensions.<TypeReference>head(_actualTypeArguments);
        _elvis = _head;
      }
      return _elvis;
    } else {
      return null;
    }
  }
  
  protected TypeReference isType(final TypeReference typeRef, final Class<? extends Property<?>> propertyType, final Class<?> clazz) {
    TypeReference _newTypeReference = this.context.newTypeReference(propertyType);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(typeRef);
    if (_isAssignableFrom) {
      return this.context.newTypeReference(clazz);
    } else {
      return null;
    }
  }
  
  protected TypeReference isListType(final TypeReference typeRef, final Class<?> clazz) {
    final TypeReference componentType = this.context.newTypeReference(clazz);
    TypeReference _newTypeReference = this.context.newTypeReference(ListProperty.class, componentType);
    boolean _isAssignableFrom = _newTypeReference.isAssignableFrom(typeRef);
    if (_isAssignableFrom) {
      return componentType;
    } else {
      return null;
    }
  }
}
